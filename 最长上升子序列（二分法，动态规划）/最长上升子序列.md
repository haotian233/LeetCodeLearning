#### 最长上升子序列

##### 动态规划

转移方程：
$$
dp[i]=max(dp[i],dp[j]+1),0<j<i\ \&\ num[j]<num[i];
$$
即考虑往 `dp[0 \ldots i-1]`中最长的上升子序列后面再加一个 `{nums}[i]`。由于 `dp[j]dp[j]` 代表 `{nums}[0 \ldots j]`中以`{nums}[j]`
结尾的最长上升子序列，所以如果能从 `dp[j]`这个状态转移过来，那么`nums[i] `必然要大于 `nums[j]`，才能将`nums[i] `放在` nums[j] `后面以形成更长的上升子序列。
最后，整个数组的最长上升子序列即所有` dp[i]` 中的最大值。
##### 二分法+贪心
考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。

基于上面的贪心思路，我们维护一个数组 d[i] ，表示长度为 i的最长上升子序列的末尾元素的最小值，用 len 记录目前最长上升子序列的长度，起始时 len 为 1，d[1]=nums[0]。

同时我们可以注意到 d[i] 是关于 ii 单调递增的。因为如果 d[j]≥d[i] 且 j<i，我们考虑从长度为 i 的最长上升子序列的末尾删除i−j 个元素，那么这个序列长度变为 j ，且第 j 个元素 xx（末尾元素）必然小于d[i]，也就小于d[j]。那么我们就找到了一个长度为 j 的最长上升子序列，并且末尾元素比 d[j]小，从而产生了矛盾。因此数组 d[]的单调性得证。

我们依次遍历数组nums[] 中的每个元素，并更新数组d[] 和 len的值。如果nums[i]>d[len] 则更新 len = len + 1len=len+1，否则在 d[1 \ldots len]d[1…len]中找满足 d[i - 1] < \textit{nums}[j] < d[i]d[i−1]<nums[j]<d[i] 的下标 ii，并更新 d[i] = \textit{nums}[j]d[i]=nums[j]。

根据 dd 数组的单调性，我们可以使用二分查找寻找下标 ii，优化时间复杂度。

最后整个算法流程为：

设当前已求出的最长上升子序列的长度为len（初始时为 11），从前往后遍历数组nums，在遍历到nums[i] 时：

如果nums[i]>d[len] ，则直接加入到 dd 数组末尾，并更新len=len+1；

否则，在 dd 数组中二分查找，找到第一个比nums[i] 小的数 d[k]，并更新 d[k + 1] = nums[i]。

以输入序列 [0, 8, 4, 12, 2]为例：

第一步插入 00，d = [0]；

第二步插入 88，d = [0, 8]；

第三步插入 44，d = [0, 4]；

第四步插入 1212，d = [0, 4, 12]；

第五步插入 22，d = [0, 2, 12]。

最终得到最大递增子序列长度为 33。
